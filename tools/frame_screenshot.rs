//! Creates a framed screenshot by superimposing a simulator screenshot into a device background image.
//!
//! The device backgrounds are those used by the simulator. Screenshots are assumed to be the correct
//! size when generated by the device simulator.
//!
//! If the `--crop-to-screenshot` flag is provided, the final image will be cropped to the dimensions
//! of the screenshot, centered on the screenshot's position.
//!
//! Usage:
//!   bazel run @rules_ciq//tools:frame_screenshot <device_background_path> <screenshot_path> <offset_x> <offset_y> <output_path> [--crop-to-screenshot]

use clap::Parser;
use image::{GenericImageView, ImageBuffer, RgbaImage};
use std::path::PathBuf;

#[derive(Parser)]
struct Args {
    device_background_path: PathBuf,
    screenshot_path: PathBuf,
    offset_x: i64,
    offset_y: i64,
    output_path: PathBuf,

    #[clap(long)]
    crop_to_screenshot: bool,
}

fn main() -> Result<(), Box<dyn std::error::Error>> {
    let args = Args::parse();

    let background_img = image::open(&args.device_background_path)?.to_rgba8();
    let screenshot_img = image::open(&args.screenshot_path)?;

    // Create a new image buffer with the dimensions of the background
    let (bg_width, bg_height) = background_img.dimensions();
    let mut canvas: RgbaImage = ImageBuffer::new(bg_width, bg_height);

    // Draw the screenshot first (at the given offset)
    image::imageops::overlay(&mut canvas, &screenshot_img, args.offset_x, args.offset_y);

    // Overlay the background on top (at 0,0)
    image::imageops::overlay(&mut canvas, &background_img, 0, 0);

    if args.crop_to_screenshot {
        let (x, y) = (args.offset_x as u32, args.offset_y as u32);
        let (width, height) = screenshot_img.dimensions();
        let cropped = image::imageops::crop(&mut canvas, x, y, width, height).to_image();
        cropped.save(&args.output_path)?;
    } else {
        canvas.save(&args.output_path)?;
    }

    Ok(())
}
